//  SwiftAPIClientCore.swift
//
//  Autogenerated by KEYPR.com with helium
//
//

import Foundation
import ReactiveSwift

public enum Result<S, E: Error> {
    case success(S)
    case failure(E)
}

public struct Request {
    public var url: URL
    public var method: RequestMethod
    public var params: [String: Any]
    public var encoding: RequestParametersEncoding
    public var expectedStatusCodes: Range<Int>
    public var expectedContentTypes: [String]
    public var headers: [String: String]

    init(
        url: URL,
        method: RequestMethod,
        encoding: RequestParametersEncoding,
        params: [String: Any] = [:],
        headers: [String: String] = [:],
        expectedStatusCodes: Range<Int> = 200..<300,
        expectedContentTypes: [String] = ["*/*"]
        ) {
        self.url = url
        self.method = method
        self.params = params
        self.encoding = encoding
        self.expectedStatusCodes = expectedStatusCodes
        self.expectedContentTypes = expectedContentTypes
        self.headers = headers
    }
}

// MARK:- Request Params Encoding
public enum RequestParametersEncoding {
    case JSON   // application JSON
    case URL    // parameters in URL
    case FORM   // parameters in BODY form-encoded
}

// MARK:- Request Method

public enum RequestMethod: String {
    case HEAD
    case GET
    case POST
    case PUT
    case DELETE
    case PATCH
}

// MARK:- Routes

public enum Route: Int {
    case unroutable
}

// MARK:- Request Provider
public typealias RequestProvider = () -> (Request)


// MARK:- Factories
public typealias GatewayFactory = (Int, APIService, @escaping RequestProvider) -> Gateway
public typealias RequestProviderFactory = (Int, @escaping RequestProvider) -> RequestProvider


// MARK:- Response
public struct APIResponse<T> {
    public let value: T
    public let response: HTTPURLResponse?

    public init(value: T, response: HTTPURLResponse? = nil) {
        self.value = value
        self.response = response
    }
}

// MARK:- Response Error

public struct APIResponseError<E: Error>: Error {
    public let error: E
    public let request: Request?
    public let response: HTTPURLResponse?

    public init(error: E, request: Request? = nil, response: HTTPURLResponse? = nil) {
        self.error = error
        self.response = response
        self.request = request
    }
}

// MARK:- Cancellable

public protocol Cancellable {
    func cancel()
}

// MARK:- Gateway

public protocol Gateway {
    func requestWithCallback<T>(
        _ responseTransformer: @escaping (Data?) -> Result<T, NSError>,
        callback: @escaping (Result<APIResponse<T>, APIResponseError<NSError>>) -> Void
    ) -> Cancellable
}

public extension Gateway {
    func request<T>(
        _ responseTransformer: @escaping (Data?) -> Result<T, NSError>,
        success: ((APIResponse<T>) -> Void)?,
        failure: ((APIResponseError<NSError>) -> Void)?
    ) -> Cancellable {
        return requestWithCallback(responseTransformer) { (result:Result<APIResponse<T>, APIResponseError<NSError>>) in
            switch result {
            case .success(let response): success?(response)
            case .failure(let responseError): failure?(responseError)
            }
        }
    }
}

// MARK: - Reactive Cocoa Gateway Extension

public extension Gateway {
    func request<T>(_ responseTransformer: @escaping (Data?) -> Result<T, NSError>) -> SignalProducer<T, APIResponseError<NSError>> {
        return SignalProducer { observer, disposable in
            let cancelable = self.requestWithCallback(responseTransformer) { (result:Result<APIResponse<T>, APIResponseError<NSError>>) in
                switch result {
                case .success(let response):
                    observer.send(value: response.value)
                    observer.sendCompleted()
                case .failure(let responseError):
                    observer.send(error: responseError)
                }
            }
            disposable.observeEnded {
                cancelable.cancel()
            }
        }
    }
}

// MARK:- Deserializable

public protocol Deserializable {
    static func deserialize(_ data: Data?) -> Result<Self, NSError>
}

public struct EmptyResponse {

}

extension EmptyResponse : Deserializable {
    public static func deserialize(_ data: Data?) -> Result<EmptyResponse, NSError> {
        return Result.success(EmptyResponse ())
    }
}

// MARK:- Network API Service Request Callback

public typealias APIServiceRequestCallback = (Result<APIResponse<Data?>, APIResponseError<NSError>>) -> Void

// MARK:- Protocol

public protocol APIService {
    func request(_ request: Request, callback: @escaping APIServiceRequestCallback) -> Cancellable
}

class GatewayImpl: Gateway {

    fileprivate let apiService: APIService
    fileprivate let requestProvider: RequestProvider

    init(apiService: APIService, requestProvider: @escaping RequestProvider) {
        self.apiService = apiService
        self.requestProvider = requestProvider
    }

    internal func requestWithCallback<T>(
        _ responseTransformer: @escaping (Data?) -> Result<T, NSError>,
        callback: @escaping (Result<APIResponse<T>, APIResponseError<NSError>>) -> Void
    ) -> Cancellable {
        let request = requestProvider()
        return apiService.request(request, callback: { result in
            switch result {
            case .success(let response):
                let responseTransformerResult = responseTransformer(response.value)
                switch responseTransformerResult {
                case .success(let transformedResponse):
                    callback(.success(APIResponse(value: transformedResponse, response: response.response)))
                case .failure(let error):
                    callback(.failure(APIResponseError(error: error, request: request, response: response.response)))
                }

            case .failure(let responseError):
                callback(.failure(responseError))
            }
        })
    }
}
